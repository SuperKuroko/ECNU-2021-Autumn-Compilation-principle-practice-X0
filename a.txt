lit 0 val :val to top
opr 0
    0: return 
    1: top = -top
    2: sop += top
    3: sop -= top
    4: sop *= top
    5: sop /= top
    6: top = top%2
    8: sop = (sop == top)
    9: sop = (sop != top)
    10:sop = (sop < top)
    11:sop = (sop >= top)
    12:sop = (sop > top)
    13:sop = (sop <= top)
    14:top->out&fout and pop
    15:\n ->out&out
    16:push.(read)
sto: top->addr & pop
cal: 
ini: s.size += a
jmp: p = i.a
jpc: if top == 0: p = i.a    must pop 

main{
	int p[10];
	p[0] = 1;
	p[1] = 2;
	p[3] = p[0] + p[1];
	write p[3];
}

0 jmp 0 1
1 int 0 13
2 lit 0 0
3 lit 0 3
4 lit 0 0
5 lit 0 1
6 sto 0 0
7 lit 0 1
8 lit 0 3
9 lit 0 0
10 lit 0 2
11 sto 0 0
12 lit 0 3
13 lit 0 3
14 lit 0 0
15 lit 0 0
16 lit 0 3
17 lit 0 0
18 lod 0 0
19 lit 0 1
20 lit 0 3
21 lit 0 0
22 lod 0 0
23 opr 0 2
24 sto 0 0
25 lit 0 3
26 lit 0 3
27 lit 0 0
28 lod 0 0
29 opr -1 14
30 opr 0 15
31 opr 0 0